<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.rdoc</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../css/github.css" type="text/css" media="screen" />
<script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            README.rdoc
        </h1>
        <ul class="files">
            <li>README.rdoc</li>
            <li>Last modified: 2012-04-27 14:25:31 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<h1 id="label-JSON+implementation+for+Ruby+%3Cimg+src%3D%22https%3A%2F%2Fsecure.travis-ci.org%2Fflori%2Fjson.png%22+%2F%3E"><a href="../classes/JSON.html">JSON</a> implementation for Ruby <a href="http://travis-ci.org/flori/json"><img src="https://secure.travis-ci.org/flori/json.png" /></a></h1>

<h2 id="label-Description">Description</h2>

<p>This is a implementation of the <a href="../classes/JSON.html">JSON</a>
specification according to RFC 4627 <a
href="http://www.ietf.org/rfc/rfc4627.txt">www.ietf.org/rfc/rfc4627.txt</a>
. Starting from version 1.0.0 on there will be two variants available:</p>
<ul><li>
<p>A pure ruby variant, that relies on the iconv and the stringscan
extensions, which are both part of the ruby standard library.</p>
</li><li>
<p>The quite a bit faster C extension variant, which is in parts implemented
in C and comes with its own unicode conversion functions and a parser
generated by the ragel state machine compiler <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a>
.</p>
</li></ul>

<p>Both variants of the <a href="../classes/JSON.html">JSON</a> generator
generate UTF-8 character sequences by default. If an :ascii_only option
with a true value is given, they escape all non-ASCII and control
characters with uXXXX escape sequences, and support UTF-16 surrogate pairs
in order to be able to generate the whole range of unicode code points.</p>

<p>All strings, that are to be encoded as <a
href="../classes/JSON.html">JSON</a> strings, should be UTF-8 byte
sequences on the Ruby side. To encode raw binary strings, that aren’t UTF-8
encoded, please use the to_json_raw_object method of String (which produces
an object, that contains a byte array) and decode the result on the
receiving endpoint.</p>

<p>The <a href="../classes/JSON.html">JSON</a> parsers can parse UTF-8,
UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE <a
href="../classes/JSON.html">JSON</a> documents under Ruby 1.8. Under Ruby
1.9 they take advantage of Ruby’s M17n features and can parse all documents
which have the correct String#encoding set. If a document string has
ASCII-8BIT as an encoding the parser attempts to figure out which of the
UTF encodings from above it is and trys to parse it.</p>

<h2 id="label-Installation">Installation</h2>

<p>It’s recommended to use the extension variant of <a
href="../classes/JSON.html">JSON</a>, because it’s faster than the pure
ruby variant. If you cannot build it on your system, you can settle for the
latter.</p>

<p>Just type into the command line as root:</p>

<pre># rake install</pre>

<p>The above command will build the extensions and install them on your
system.</p>

<pre># rake install_pure</pre>

<p>or</p>

<pre># ruby install.rb</pre>

<p>will just install the pure ruby implementation of <a
href="../classes/JSON.html">JSON</a>.</p>

<p>If you use Rubygems you can type</p>

<pre># gem install json</pre>

<p>instead, to install the newest <a href="../classes/JSON.html">JSON</a>
version.</p>

<p>There is also a pure ruby json only variant of the gem, that can be
installed with:</p>

<pre># gem install json_pure</pre>

<h2 id="label-Compiling+the+extensions+yourself">Compiling the extensions yourself</h2>

<p>If you want to build the extensions yourself you need rake:</p>

<pre>You can get it from rubyforge:
  http://rubyforge.org/projects/rake

or just type

# gem install rake

for the installation via rubygems.</pre>

<p>If you want to create the parser.c file from its parser.rl file or draw
nice graphviz images of the state machines, you need ragel from: <a
href="http://www.cs.queensu.ca/~thurston/ragel">www.cs.queensu.ca/~thurston/ragel</a></p>

<h2 id="label-Usage">Usage</h2>

<p>To use <a href="../classes/JSON.html">JSON</a> you can</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json'</span>
</pre>

<p>to load the installed variant (either the extension ‘json’ or the pure
variant ‘json_pure’). If you have installed the extension variant, you can
pick either the extension variant or the pure variant by typing</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/ext'</span>
</pre>

<p>or</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/pure'</span>
</pre>

<p>Now you can parse a <a href="../classes/JSON.html">JSON</a> document into a
ruby data structure by calling</p>

<pre>JSON.parse(document)</pre>

<p>If you want to generate a <a href="../classes/JSON.html">JSON</a> document
from a ruby data structure call</p>

<pre>JSON.generate(data)</pre>

<p>You can also use the pretty_generate method (which formats the output more
verbosely and nicely) or fast_generate (which doesn’t do any of the
security checks generate performs, e. g. nesting deepness checks).</p>

<p>To create a valid <a href="../classes/JSON.html">JSON</a> document you have
to make sure, that the output is embedded in either a <a
href="../classes/JSON.html">JSON</a> array [] or a <a
href="../classes/JSON.html">JSON</a> object {}. The easiest way to do this,
is by putting your values in a Ruby Array or Hash instance.</p>

<p>There are also the <a href="../classes/JSON.html">JSON</a> and JSON[]
methods which use parse on a String or generate a <a
href="../classes/JSON.html">JSON</a> document from an array or hash:</p>

<pre class="ruby"><span class="ruby-identifier">document</span> = <span class="ruby-constant">JSON</span> <span class="ruby-string">'test'</span>  =<span class="ruby-operator">&gt;</span> <span class="ruby-value">23</span> <span class="ruby-comment"># =&gt; &quot;{\&quot;test\&quot;:23}&quot;</span>
<span class="ruby-identifier">document</span> = <span class="ruby-constant">JSON</span>[<span class="ruby-string">'test'</span>] =<span class="ruby-operator">&gt;</span> <span class="ruby-value">23</span> <span class="ruby-comment"># =&gt; &quot;{\&quot;test\&quot;:23}&quot;</span>
</pre>

<p>and</p>

<pre class="ruby"><span class="ruby-identifier">data</span> = <span class="ruby-constant">JSON</span> <span class="ruby-string">'{&quot;test&quot;:23}'</span>  <span class="ruby-comment"># =&gt; {&quot;test&quot;=&gt;23}</span>
<span class="ruby-identifier">data</span> = <span class="ruby-constant">JSON</span>[<span class="ruby-string">'{&quot;test&quot;:23}'</span>] <span class="ruby-comment"># =&gt; {&quot;test&quot;=&gt;23}</span>
</pre>

<p>You can choose to load a set of common additions to ruby core’s objects if
you</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/add/core'</span>
</pre>

<p>After requiring this you can, e. g., serialise/deserialise Ruby ranges:</p>

<pre class="ruby"><span class="ruby-constant">JSON</span> <span class="ruby-constant">JSON</span>(<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>) <span class="ruby-comment"># =&gt; 1..10</span>
</pre>

<p>To find out how to add <a href="../classes/JSON.html">JSON</a> support to
other or your own classes, read the section “More Examples” below.</p>

<p>To get the best compatibility to rails’ <a
href="../classes/JSON.html">JSON</a> implementation, you can</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'json/add/rails'</span>
</pre>

<p>Both of the additions attempt to require ‘json’ (like above) first, if it
has not been required yet.</p>

<h2 id="label-More+Examples">More Examples</h2>

<p>To create a <a href="../classes/JSON.html">JSON</a> document from a ruby
data structure, you can call <a
href="../classes/JSON.html#method-i-generate">JSON#generate</a> like that:</p>

<pre class="ruby"><span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,\&quot;4..10\&quot;]&quot;</span>
</pre>

<p>To get back a ruby data structure from a <a
href="../classes/JSON.html">JSON</a> document, you have to call <a
href="../classes/JSON.html#method-i-parse">JSON#parse</a> on it:</p>

<pre class="ruby"><span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, &quot;4..10&quot;]</span>
</pre>

<p>Note, that the range from the original data structure is a simple string
now. The reason for this is, that <a href="../classes/JSON.html">JSON</a>
doesn’t support ranges or arbitrary classes. In this case the json library
falls back to call Object#to_json, which is the same as to_s.to_json.</p>

<p>It’s possible to add <a href="../classes/JSON.html">JSON</a> support
serialization to arbitrary classes by simply implementing a more
specialized version of the to_json method, that should return a <a
href="../classes/JSON.html">JSON</a> object (a hash converted to <a
href="../classes/JSON.html">JSON</a> with to_json) like this (don’t forget
the *a for all the arguments):</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Range</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier">to_json</span>(*<span class="ruby-identifier">a</span>)
    {
      <span class="ruby-string">'json_class'</span>   =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-comment"># = 'Range'</span>
      <span class="ruby-string">'data'</span>         =<span class="ruby-operator">&gt;</span> [ <span class="ruby-identifier">first</span>, <span class="ruby-identifier">last</span>, <span class="ruby-identifier">exclude_end?</span> ]
    }.<span class="ruby-identifier">to_json</span>(*<span class="ruby-identifier">a</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>The hash key ‘json_class’ is the class, that will be asked to deserialise
the <a href="../classes/JSON.html">JSON</a> representation later. In this
case it’s ‘Range’, but any namespace of the form ‘A::B’ or ‘::A::B’ will
do. All other keys are arbitrary and can be used to store the necessary
data to configure the object to be deserialised.</p>

<p>If a the key ‘json_class’ is found in a <a
href="../classes/JSON.html">JSON</a> object, the <a
href="../classes/JSON.html">JSON</a> parser checks if the given class
responds to the json_create class method. If so, it is called with the <a
href="../classes/JSON.html">JSON</a> object converted to a Ruby hash. So a
range can be deserialised by implementing <a
href="../classes/Range.html#method-c-json_create">Range.json_create</a>
like this:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">Range</span>
  <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">json_create</span>(<span class="ruby-identifier">o</span>)
    <span class="ruby-identifier">new</span>(*<span class="ruby-identifier">o</span>[<span class="ruby-string">'data'</span>])
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>Now it possible to serialise/deserialise ranges as well:</p>

<pre class="ruby"><span class="ruby-identifier">json</span> = <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">generate</span> [<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>]
<span class="ruby-comment"># =&gt; &quot;[1,2,{\&quot;a\&quot;:3.141},false,true,null,{\&quot;json_class\&quot;:\&quot;Range\&quot;,\&quot;data\&quot;:[4,10,false]}]&quot;</span>
<span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span> <span class="ruby-identifier">json</span>
<span class="ruby-comment"># =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]</span>
</pre>

<p><a href="../classes/JSON.html#method-i-generate">JSON#generate</a> always
creates the shortest possible string representation of a ruby data
structure in one line. This is good for data storage or network protocols,
but not so good for humans to read. Fortunately there's also <a
href="../classes/JSON.html#method-i-pretty_generate">JSON#pretty_generate</a>
(or <a
href="../classes/JSON.html#method-i-pretty_generate">JSON#pretty_generate</a>)
that creates a more readable output:</p>

<pre class="ruby"><span class="ruby-identifier">puts</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">pretty_generate</span>([<span class="ruby-value">1</span>, <span class="ruby-value">2</span>, {<span class="ruby-string">&quot;a&quot;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-value">3.141</span>}, <span class="ruby-keyword">false</span>, <span class="ruby-keyword">true</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">10</span>])
[
  <span class="ruby-value">1</span>,
  <span class="ruby-value">2</span>,
  {
    <span class="ruby-string">&quot;a&quot;</span><span class="ruby-operator">:</span> <span class="ruby-value">3.141</span>
  },
  <span class="ruby-keyword">false</span>,
  <span class="ruby-keyword">true</span>,
  <span class="ruby-identifier">null</span>,
  {
    <span class="ruby-string">&quot;json_class&quot;</span><span class="ruby-operator">:</span> <span class="ruby-string">&quot;Range&quot;</span>,
    <span class="ruby-string">&quot;data&quot;</span><span class="ruby-operator">:</span> [
      <span class="ruby-value">4</span>,
      <span class="ruby-value">10</span>,
      <span class="ruby-keyword">false</span>
    ]
  }
]
</pre>

<p>There are also the methods Kernel#j for generate, and Kernel#jj for
pretty_generate output to the console, that work analogous to Core Ruby’s p
and the pp library’s pp methods.</p>

<p>The script tools/server.rb contains a small example if you want to test,
how receiving a <a href="../classes/JSON.html">JSON</a> object from a
webrick server in your browser with the javasript prototype library <a
href="http://www.prototypejs.org">www.prototypejs.org</a> works.</p>

<h2 id="label-Speed+Comparisons">Speed Comparisons</h2>

<p>I have created some benchmark results (see the benchmarks/data-p4-3Ghz
subdir of the package) for the JSON-parser to estimate the speed up in the
C extension:</p>

<pre>Comparing times (call_time_mean):
 1 ParserBenchmarkExt#parser   900 repeats:
       553.922304770 (  real) -&gt;   21.500x 
         0.001805307
 2 ParserBenchmarkYAML#parser  1000 repeats:
       224.513358139 (  real) -&gt;    8.714x 
         0.004454078
 3 ParserBenchmarkPure#parser  1000 repeats:
        26.755020642 (  real) -&gt;    1.038x 
         0.037376163
 4 ParserBenchmarkRails#parser 1000 repeats:
        25.763381731 (  real) -&gt;    1.000x 
         0.038814780
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<p>In the table above 1 is <a
href="../classes/JSON/Ext/Parser.html">JSON::Ext::Parser</a>, 2 is
YAML.load with YAML compatbile <a href="../classes/JSON.html">JSON</a>
document, 3 is is <a
href="../classes/JSON/Pure/Parser.html">JSON::Pure::Parser</a>, and 4 is
ActiveSupport::JSON.decode. The ActiveSupport JSON-decoder converts the
input first to YAML and then uses the YAML-parser, the conversion seems to
slow it down so much that it is only as fast as the <a
href="../classes/JSON/Pure/Parser.html">JSON::Pure::Parser</a>!</p>

<p>If you look at the benchmark data you can see that this is mostly caused by
the frequent high outliers - the median of the Rails-parser runs is still
overall smaller than the median of the <a
href="../classes/JSON/Pure/Parser.html">JSON::Pure::Parser</a> runs:</p>

<pre>Comparing times (call_time_median):
 1 ParserBenchmarkExt#parser   900 repeats:
       800.592479481 (  real) -&gt;   26.936x 
         0.001249075
 2 ParserBenchmarkYAML#parser  1000 repeats:
       271.002390644 (  real) -&gt;    9.118x 
         0.003690004
 3 ParserBenchmarkRails#parser 1000 repeats:
        30.227910865 (  real) -&gt;    1.017x 
         0.033082008
 4 ParserBenchmarkPure#parser  1000 repeats:
        29.722384421 (  real) -&gt;    1.000x 
         0.033644676
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<p>I have benchmarked the JSON-Generator as well. This generated a few more
values, because there are different modes that also influence the achieved
speed:</p>

<pre>Comparing times (call_time_mean):
 1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
       547.354332608 (  real) -&gt;   15.090x 
         0.001826970
 2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
       443.968212317 (  real) -&gt;   12.240x 
         0.002252414
 3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
       375.104545883 (  real) -&gt;   10.341x 
         0.002665923
 4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
        49.978706968 (  real) -&gt;    1.378x 
         0.020008521
 5 GeneratorBenchmarkRails#generator       1000 repeats:
        38.531868759 (  real) -&gt;    1.062x 
         0.025952543
 6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
        36.927649925 (  real) -&gt;    1.018x 7 (&gt;=3859)
         0.027079979
 7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
        36.272134441 (  real) -&gt;    1.000x 6 (&gt;=3859)
         0.027569373
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<p>In the table above 1-3 are <a
href="../classes/JSON/Ext/Generator.html">JSON::Ext::Generator</a> methods.
4, 6, and 7 are <a
href="../classes/JSON/Pure/Generator.html">JSON::Pure::Generator</a>
methods and 5 is the Rails <a href="../classes/JSON.html">JSON</a>
generator. It is now a bit faster than the generator_safe and
generator_pretty methods of the pure variant but slower than the others.</p>

<p>To achieve the fastest <a href="../classes/JSON.html">JSON</a> document
output, you can use the fast_generate method. Beware, that this will
disable the checking for circular Ruby data structures, which may cause <a
href="../classes/JSON.html">JSON</a> to go into an infinite loop.</p>

<p>Here are the median comparisons for completeness’ sake:</p>

<pre>Comparing times (call_time_median):
 1 GeneratorBenchmarkExt#generator_fast    1000 repeats:
       708.258020939 (  real) -&gt;   16.547x 
         0.001411915
 2 GeneratorBenchmarkExt#generator_safe    1000 repeats:
       569.105020353 (  real) -&gt;   13.296x 
         0.001757145
 3 GeneratorBenchmarkExt#generator_pretty  900 repeats:
       482.825371244 (  real) -&gt;   11.280x 
         0.002071142
 4 GeneratorBenchmarkPure#generator_fast   1000 repeats:
        62.717626652 (  real) -&gt;    1.465x 
         0.015944481
 5 GeneratorBenchmarkRails#generator       1000 repeats:
        43.965681162 (  real) -&gt;    1.027x 
         0.022745013
 6 GeneratorBenchmarkPure#generator_safe   1000 repeats:
        43.929073409 (  real) -&gt;    1.026x 7 (&gt;=3859)
         0.022763968
 7 GeneratorBenchmarkPure#generator_pretty 1000 repeats:
        42.802514491 (  real) -&gt;    1.000x 6 (&gt;=3859)
         0.023363113
           calls/sec (  time) -&gt;    speed  covers
           secs/call</pre>

<h2 id="label-Author">Author</h2>

<p>Florian Frank &lt;<a href="mailto:flori@ping.de">flori@ping.de</a>&gt;</p>

<h2 id="label-License">License</h2>

<p>Ruby License, see the COPYING file included in the source distribution. The
Ruby License includes the GNU General Public License (GPL), Version 2, so
see the file GPL as well.</p>

<h2 id="label-Download">Download</h2>

<p>The latest version of this library can be downloaded at</p>
<ul><li>
<p><a
href="http://rubyforge.org/frs?group_id=953">rubyforge.org/frs?group_id=953</a></p>
</li></ul>

<p>Online Documentation should be located at</p>
<ul><li>
<p><a href="http://json.rubyforge.org">json.rubyforge.org</a></p>
</li></ul>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>
    </div>
  </body>
</html>